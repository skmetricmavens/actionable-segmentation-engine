"""
Pudding.cool-style HTML renderer for visual essays.

Creates smooth scrollytelling experiences with:
- Sticky graphics that update on scroll
- Progress-based animations (not just step triggers)
- Smooth opacity transitions for focus states
- Rich, polished visualizations
"""

import json
from pathlib import Path
from typing import Any

from src.essays.base import Essay, EssayConfig


def render_pudding_essay(essay: Essay, config: EssayConfig | None = None) -> str:
    """Render essay in Pudding.cool style with proper scrollytelling."""
    config = config or EssayConfig()

    # Extract all chart data
    chart_data = {}
    for section in essay.sections:
        chart_data[section.chart.chart_id] = section.chart.to_dict()
        for chart in section.supporting_charts:
            chart_data[chart.chart_id] = chart.to_dict()

    chart_json = json.dumps(chart_data, default=str, indent=2)

    # Build sections HTML
    sections_html = []
    for section in essay.sections:
        sections_html.append(_render_section(section))

    # Build key insights HTML
    insights_html = ""
    for insight in essay.key_insights[:6]:
        insights_html += f'''
            <div class="insight-card">
                <span class="insight-value">{insight.metric_value}</span>
                <span class="insight-label">{insight.metric_label}</span>
            </div>'''

    # Build TOC
    toc_html = ""
    for i, entry in enumerate(essay.toc_entries, 1):
        toc_html += f'<li><a href="#{entry["id"]}">{entry["title"]}</a></li>'

    return f'''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{essay.title}</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/scrollama@3.2.0/build/scrollama.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
{_get_pudding_css()}
    </style>
</head>
<body>
    <!-- Hero Section -->
    <header class="hero">
        <div class="hero-content">
            <h1 class="hero-title">{essay.title}</h1>
            <p class="hero-subtitle">{essay.subtitle}</p>
            <div class="key-insights">
                {insights_html}
            </div>
            <div class="scroll-cue">
                <span>Scroll to explore</span>
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 5v14M5 12l7 7 7-7"/>
                </svg>
            </div>
        </div>
    </header>

    <!-- Table of Contents -->
    <nav class="toc">
        <div class="toc-inner">
            <h2>What you'll discover</h2>
            <ol>{toc_html}</ol>
        </div>
    </nav>

    <!-- Essay Sections -->
    <main class="essay">
        {"".join(sections_html)}
    </main>

    <!-- Footer -->
    <footer class="footer">
        <p>Generated by Actionable Segmentation Engine</p>
        <p class="footer-meta">Based on {essay.customer_count:,} customer profiles</p>
    </footer>

    <!-- Tooltip -->
    <div id="tooltip" class="tooltip"></div>

    <!-- Chart Data -->
    <script>
        window.ESSAY_DATA = {chart_json};
    </script>

    <!-- Main Script -->
    <script>
{_get_pudding_js()}
    </script>
</body>
</html>'''


def _render_section(section) -> str:
    """Render a single essay section with scrollytelling."""
    # Build steps HTML
    steps_html = ""

    # Add headline step
    steps_html += f'''
        <div class="step" data-step="0" data-action="init">
            <div class="step-content step-headline">
                <span class="step-eyebrow">Key Insight</span>
                <h3>{section.narrative.headline}</h3>
            </div>
        </div>'''

    # Add scrolly steps
    for step in section.scrolly_steps:
        steps_html += f'''
        <div class="step" data-step="{step.step_number}" data-action="{step.chart_action}" data-params='{json.dumps(step.action_params)}'>
            <div class="step-content">
                <p>{step.narrative_text}</p>
            </div>
        </div>'''

    # Add callout step
    steps_html += f'''
        <div class="step" data-step="final" data-action="showAll">
            <div class="step-content step-callout">
                <span class="callout-icon">ðŸ’¡</span>
                <p>{section.narrative.callout}</p>
            </div>
        </div>'''

    return f'''
    <section id="{section.section_id}" class="essay-section">
        <!-- Section Header -->
        <div class="section-intro">
            <span class="section-number">{section.section_id.split('-')[0].upper()}</span>
            <h2 class="section-title">{section.title}</h2>
            <p class="section-summary">{section.executive_summary}</p>
        </div>

        <!-- Scrollytelling Container -->
        <div class="scrolly" data-chart-id="{section.chart.chart_id}">
            <!-- Sticky Graphic -->
            <figure class="scrolly-figure">
                <div class="chart-container">
                    <div class="chart-title-bar">
                        <h4 class="chart-title">{section.chart.config.get('title', section.title)}</h4>
                    </div>
                    <div class="chart" id="chart-{section.chart.chart_id}"></div>
                </div>
            </figure>

            <!-- Scroll Steps -->
            <article class="scrolly-article">
                {steps_html}
            </article>
        </div>

        <!-- Expandable Details -->
        <div class="section-details">
            <details class="details-block">
                <summary>
                    <span class="details-icon">ðŸ“Š</span>
                    Read the full analysis
                </summary>
                <div class="details-content">
                    {section.marketing_narrative.replace(chr(10), '<br>')}
                </div>
            </details>

            <details class="details-block">
                <summary>
                    <span class="details-icon">ðŸ”¬</span>
                    Technical methodology
                </summary>
                <div class="details-content technical">
                    {section.technical_details.replace(chr(10), '<br>')}
                </div>
            </details>
        </div>
    </section>'''


def _get_pudding_css() -> str:
    """Get Pudding.cool-style CSS with rich visual polish."""
    return '''
/* ============================================
   PUDDING.COOL INSPIRED - PREMIUM CSS
   ============================================ */

:root {
    /* Colors - Sophisticated palette */
    --color-bg: #fafbfc;
    --color-surface: #ffffff;
    --color-text: #1a1a2e;
    --color-text-muted: #64748b;
    --color-text-light: #94a3b8;

    /* Accent colors */
    --color-primary: #6366f1;
    --color-primary-light: #818cf8;
    --color-primary-dark: #4f46e5;
    --color-secondary: #ec4899;
    --color-success: #10b981;
    --color-warning: #f59e0b;
    --color-danger: #ef4444;

    /* Chart colors */
    --chart-1: #6366f1;
    --chart-2: #22c55e;
    --chart-3: #f59e0b;
    --chart-4: #ef4444;
    --chart-5: #8b5cf6;
    --chart-6: #06b6d4;

    /* Spacing */
    --space-xs: 0.5rem;
    --space-sm: 1rem;
    --space-md: 1.5rem;
    --space-lg: 2rem;
    --space-xl: 3rem;
    --space-2xl: 5rem;

    /* Typography */
    --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    --font-display: 'Playfair Display', Georgia, serif;

    /* Transitions */
    --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
    --transition-fast: 150ms var(--ease-out-expo);
    --transition-medium: 300ms var(--ease-out-expo);
    --transition-slow: 500ms var(--ease-out-expo);

    /* Shadows */
    --shadow-sm: 0 1px 2px rgba(0,0,0,0.04);
    --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
    --shadow-lg: 0 12px 40px rgba(0,0,0,0.12);
    --shadow-glow: 0 0 40px rgba(99, 102, 241, 0.15);
}

* { box-sizing: border-box; }

html {
    scroll-behavior: smooth;
}

body {
    font-family: var(--font-sans);
    background: var(--color-bg);
    color: var(--color-text);
    margin: 0;
    padding: 0;
    line-height: 1.7;
    font-size: 17px;
    -webkit-font-smoothing: antialiased;
}

/* ============================================
   HERO SECTION
   ============================================ */

.hero {
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, #1e1b4b 0%, #312e81 50%, #4338ca 100%);
    color: white;
    text-align: center;
    padding: var(--space-lg);
    position: relative;
    overflow: hidden;
}

.hero::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.03'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
    opacity: 0.5;
}

.hero-content {
    max-width: 900px;
    position: relative;
    z-index: 1;
}

.hero-title {
    font-family: var(--font-display);
    font-size: clamp(2.5rem, 7vw, 5rem);
    font-weight: 700;
    margin: 0 0 var(--space-md);
    letter-spacing: -0.02em;
    line-height: 1.1;
    text-shadow: 0 4px 30px rgba(0,0,0,0.3);
}

.hero-subtitle {
    font-size: clamp(1.1rem, 2.5vw, 1.4rem);
    opacity: 0.9;
    margin: 0 0 var(--space-xl);
    font-weight: 300;
    max-width: 600px;
    margin-left: auto;
    margin-right: auto;
}

.key-insights {
    display: flex;
    justify-content: center;
    gap: var(--space-md);
    flex-wrap: wrap;
    margin: var(--space-xl) 0;
    padding-bottom: 80px; /* Leave room for scroll indicator */
}

.insight-card {
    background: rgba(255,255,255,0.1);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 16px;
    padding: var(--space-md) var(--space-lg);
    min-width: 150px;
    transition: var(--transition-medium);
    cursor: default;
}

.insight-card:hover {
    transform: translateY(-4px);
    background: rgba(255,255,255,0.15);
    box-shadow: var(--shadow-glow);
}

.insight-value {
    display: block;
    font-size: 2.2rem;
    font-weight: 800;
    background: linear-gradient(135deg, #22c55e 0%, #10b981 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    line-height: 1.2;
}

.insight-label {
    display: block;
    font-size: 0.8rem;
    opacity: 0.7;
    margin-top: var(--space-xs);
    text-transform: uppercase;
    letter-spacing: 0.08em;
    font-weight: 500;
}

.scroll-cue {
    position: absolute;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    animation: float 3s ease-in-out infinite;
    z-index: 10;
    color: rgba(255, 255, 255, 0.9);
}

.scroll-cue span {
    font-size: 0.75rem;
    font-weight: 500;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.8);
}

.scroll-cue svg {
    width: 20px;
    height: 20px;
    stroke: rgba(255, 255, 255, 0.8);
    animation: bounce 2s ease-in-out infinite;
}

@keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(6px); }
}

@keyframes float {
    0%, 100% { transform: translateX(-50%) translateY(0); }
    50% { transform: translateX(-50%) translateY(-8px); }
}

/* ============================================
   TABLE OF CONTENTS
   ============================================ */

.toc {
    background: var(--color-surface);
    padding: var(--space-2xl) var(--space-lg);
    border-bottom: 1px solid rgba(0,0,0,0.05);
}

.toc-inner {
    max-width: 700px;
    margin: 0 auto;
}

.toc h2 {
    font-size: 0.9rem;
    color: var(--color-text-muted);
    margin: 0 0 var(--space-lg);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.1em;
}

.toc ol {
    margin: 0;
    padding: 0;
    list-style: none;
    display: grid;
    gap: var(--space-sm);
}

.toc li {
    counter-increment: toc-counter;
    display: flex;
    align-items: center;
    gap: var(--space-md);
}

.toc li::before {
    content: counter(toc-counter);
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    background: var(--color-primary);
    color: white;
    border-radius: 50%;
    font-size: 0.85rem;
    font-weight: 600;
    flex-shrink: 0;
}

.toc a {
    color: var(--color-text);
    text-decoration: none;
    font-weight: 500;
    font-size: 1.05rem;
    transition: var(--transition-fast);
    padding: var(--space-sm) 0;
    display: block;
    width: 100%;
}

.toc a:hover {
    color: var(--color-primary);
    transform: translateX(4px);
}

/* ============================================
   ESSAY SECTIONS
   ============================================ */

.essay {
    max-width: 100%;
}

.essay-section {
    margin: 0;
    padding: 0;
}

.section-intro {
    max-width: 700px;
    margin: 0 auto;
    padding: var(--space-2xl) var(--space-lg);
    text-align: center;
}

.section-number {
    display: inline-block;
    background: var(--color-primary);
    color: white;
    font-size: 0.75rem;
    font-weight: 700;
    padding: var(--space-xs) var(--space-sm);
    border-radius: 4px;
    letter-spacing: 0.1em;
    margin-bottom: var(--space-md);
}

.section-title {
    font-family: var(--font-display);
    font-size: clamp(2rem, 4vw, 3rem);
    font-weight: 700;
    margin: 0 0 var(--space-md);
    color: var(--color-text);
    line-height: 1.2;
}

.section-summary {
    font-size: 1.15rem;
    color: var(--color-text-muted);
    margin: 0;
    line-height: 1.7;
}

/* ============================================
   SCROLLYTELLING - THE MAGIC
   ============================================ */

.scrolly {
    position: relative;
    display: flex;
    background: linear-gradient(180deg, #f8fafc 0%, var(--color-surface) 100%);
}

.scrolly-figure {
    position: sticky;
    top: 0;
    flex: 1;
    height: 100vh;
    margin: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: var(--space-lg);
}

.chart-container {
    width: 100%;
    max-width: 700px;
    background: var(--color-surface);
    border-radius: 20px;
    box-shadow: var(--shadow-lg);
    overflow: hidden;
    transition: var(--transition-slow);
}

.chart-title-bar {
    padding: var(--space-md) var(--space-lg);
    border-bottom: 1px solid rgba(0,0,0,0.05);
    background: linear-gradient(180deg, #fefefe 0%, #f8fafc 100%);
}

.chart-title {
    margin: 0;
    font-size: 1rem;
    font-weight: 600;
    color: var(--color-text);
}

.chart {
    padding: var(--space-lg);
    min-height: 400px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.chart svg {
    width: 100%;
    height: 100%;
    overflow: visible;
}

.scrolly-article {
    flex: 0 0 45%;
    padding: 0;
    position: relative;
    z-index: 10;
}

.step {
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: var(--space-lg);
}

.step-content {
    background: var(--color-surface);
    padding: var(--space-lg) var(--space-xl);
    border-radius: 16px;
    box-shadow: var(--shadow-md);
    max-width: 380px;
    opacity: 0.2;
    transform: translateY(30px);
    transition: all 0.5s var(--ease-out-expo);
    border: 1px solid rgba(0,0,0,0.04);
}

.step.is-active .step-content {
    opacity: 1;
    transform: translateY(0);
    box-shadow: var(--shadow-lg), var(--shadow-glow);
}

/* Scroll-triggered animations */
.essay-section {
    opacity: 0;
    transform: translateY(40px);
    transition: opacity 0.8s ease-out, transform 0.8s ease-out;
}

.essay-section.in-view {
    opacity: 1;
    transform: translateY(0);
}

/* Chart container animations */
[id^="chart-"] {
    will-change: transform, opacity;
}

[id^="chart-"].animated {
    animation: chartReveal 0.8s ease-out forwards;
}

@keyframes chartReveal {
    from {
        opacity: 0;
        transform: translateY(30px) scale(0.98);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

/* Rich hover states for interactive elements */
.bar-rect, .scatter-point, .node, .funnel-stage rect {
    transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    cursor: pointer;
}

.bar-rect:hover, .funnel-stage rect:hover {
    filter: brightness(1.15);
    transform: scaleY(1.02);
}

.scatter-point:hover, .node:hover {
    transform: scale(1.3);
    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.2));
}

/* Highlight/dim states for focus */
.dimmed {
    opacity: 0.15 !important;
    filter: grayscale(0.8);
    transition: all 0.5s ease-out;
}

.highlighted {
    opacity: 1 !important;
    filter: none;
    transform: scale(1.05);
    z-index: 10;
}

/* Smooth scrolly figure transitions */
.scrolly-figure {
    transition: transform 0.3s ease-out;
    will-change: transform;
}

.step-eyebrow {
    display: block;
    font-size: 0.75rem;
    font-weight: 600;
    color: var(--color-primary);
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-bottom: var(--space-sm);
}

.step-headline h3 {
    font-size: 1.4rem;
    margin: 0;
    color: var(--color-text);
    font-weight: 700;
    line-height: 1.3;
}

.step-content p {
    font-size: 1.05rem;
    margin: 0;
    color: var(--color-text);
    line-height: 1.7;
}

.step-callout {
    background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
    color: white;
    text-align: center;
}

.step-callout p {
    color: white;
}

.callout-icon {
    display: block;
    font-size: 2rem;
    margin-bottom: var(--space-sm);
}

/* ============================================
   EXPANDABLE DETAILS
   ============================================ */

.section-details {
    max-width: 800px;
    margin: 0 auto;
    padding: var(--space-xl) var(--space-lg);
    display: grid;
    gap: var(--space-md);
}

.details-block {
    background: var(--color-surface);
    border-radius: 12px;
    border: 1px solid rgba(0,0,0,0.06);
    overflow: hidden;
}

.details-block summary {
    cursor: pointer;
    padding: var(--space-md) var(--space-lg);
    font-weight: 600;
    color: var(--color-text);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    transition: var(--transition-fast);
    list-style: none;
}

.details-block summary::-webkit-details-marker {
    display: none;
}

.details-block summary::after {
    content: '+';
    margin-left: auto;
    font-size: 1.5rem;
    font-weight: 300;
    color: var(--color-text-muted);
    transition: var(--transition-fast);
}

.details-block[open] summary::after {
    transform: rotate(45deg);
}

.details-block summary:hover {
    background: rgba(99, 102, 241, 0.04);
}

.details-icon {
    font-size: 1.2rem;
}

.details-content {
    padding: 0 var(--space-lg) var(--space-lg);
    color: var(--color-text-muted);
    line-height: 1.8;
}

.details-content.technical {
    font-family: 'SF Mono', Monaco, monospace;
    font-size: 0.9rem;
    background: #f8fafc;
    margin: 0 var(--space-md) var(--space-md);
    padding: var(--space-md);
    border-radius: 8px;
}

/* ============================================
   FOOTER
   ============================================ */

.footer {
    text-align: center;
    padding: var(--space-2xl) var(--space-lg);
    background: var(--color-text);
    color: white;
}

.footer p {
    margin: var(--space-xs) 0;
}

.footer-meta {
    opacity: 0.5;
    font-size: 0.9rem;
}

/* ============================================
   TOOLTIP
   ============================================ */

.tooltip {
    position: fixed;
    background: var(--color-text);
    color: white;
    padding: 12px 16px;
    border-radius: 10px;
    font-size: 0.9rem;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    z-index: 1000;
    max-width: 280px;
    line-height: 1.5;
    box-shadow: var(--shadow-lg);
}

.tooltip.visible {
    opacity: 1;
}

.tooltip-title {
    font-weight: 700;
    margin-bottom: 4px;
}

.tooltip-value {
    font-size: 1.1rem;
    font-weight: 700;
    color: var(--color-success);
}

/* ============================================
   CHART STYLES
   ============================================ */

/* Funnel specific */
.funnel-stage {
    transition: all 0.4s var(--ease-out-expo);
}

.funnel-stage:hover {
    filter: brightness(1.05);
}

.funnel-stage.dimmed {
    opacity: 0.25;
}

.funnel-stage.highlighted {
    filter: brightness(1.1) drop-shadow(0 4px 20px rgba(99, 102, 241, 0.3));
}

.funnel-dropoff {
    fill: var(--color-danger);
    opacity: 0.15;
}

.funnel-label {
    font-size: 13px;
    font-weight: 600;
    fill: var(--color-text);
}

.funnel-value {
    font-size: 18px;
    font-weight: 700;
    fill: white;
}

.funnel-pct {
    font-size: 12px;
    font-weight: 600;
    fill: var(--color-text-muted);
}

/* Bar chart styles */
.bar-rect {
    transition: all 0.3s var(--ease-out-expo);
}

.bar-rect:hover {
    filter: brightness(1.1);
}

.bar-rect.dimmed {
    opacity: 0.2;
}

.bar-rect.highlighted {
    filter: brightness(1.15) drop-shadow(0 2px 8px rgba(0,0,0,0.2));
}

/* Scatter styles */
.scatter-point {
    transition: all 0.3s var(--ease-out-expo);
}

.scatter-point:hover {
    transform: scale(1.3);
}

.scatter-point.dimmed {
    opacity: 0.15;
}

.scatter-point.highlighted {
    filter: drop-shadow(0 0 12px rgba(99, 102, 241, 0.5));
}

/* Axis styles */
.axis path,
.axis line {
    stroke: #e2e8f0;
}

.axis text {
    fill: var(--color-text-muted);
    font-size: 12px;
}

.axis-label {
    fill: var(--color-text-muted);
    font-size: 13px;
    font-weight: 500;
}

/* ============================================
   RESPONSIVE
   ============================================ */

@media (max-width: 900px) {
    .scrolly {
        flex-direction: column;
    }

    .scrolly-figure {
        position: relative;
        height: 70vh;
        min-height: 450px;
    }

    .scrolly-article {
        flex: none;
    }

    .step {
        min-height: auto;
        padding: var(--space-xl) var(--space-md);
    }

    .step-content {
        max-width: 100%;
        opacity: 1;
        transform: none;
    }

    .key-insights {
        gap: var(--space-sm);
    }

    .insight-card {
        min-width: 130px;
        padding: var(--space-sm) var(--space-md);
    }

    .insight-value {
        font-size: 1.6rem;
    }
}
'''


def _get_pudding_js() -> str:
    """Get Pudding.cool-style JavaScript with rich interactions."""
    return '''
// ============================================
// PUDDING.COOL INSPIRED - PREMIUM JS
// ============================================

(function() {
    'use strict';

    // ============================================
    // CONFIGURATION
    // ============================================

    const CONFIG = {
        colors: {
            primary: '#6366f1',
            primaryLight: '#818cf8',
            success: '#10b981',
            warning: '#f59e0b',
            danger: '#ef4444',
            muted: '#64748b',
            chart: ['#6366f1', '#22c55e', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4']
        },
        animation: {
            duration: 800,
            stagger: 60,
            easing: d3.easeCubicOut
        }
    };

    // State
    const state = {
        charts: {},
        activeSteps: new Map()
    };

    // Tooltip
    const tooltip = d3.select('#tooltip');

    // ============================================
    // INITIALIZATION
    // ============================================

    document.addEventListener('DOMContentLoaded', init);

    function init() {
        renderMarkdownContent();
        initKpiTooltips();
        initCharts();
        initScrollAnimations();
        initScrollama();
        initSmoothScroll();
        initHeroAnimations();
        console.log('Pudding essay initialized with rich animations');
    }

    function initHeroAnimations() {
        // Animate hero elements on load
        const hero = document.querySelector('.hero-content');
        if (!hero) return;

        const title = hero.querySelector('.hero-title');
        const subtitle = hero.querySelector('.hero-subtitle');
        const insights = hero.querySelectorAll('.insight-card');

        // Stagger entrance animations
        if (title) {
            title.style.opacity = '0';
            title.style.transform = 'translateY(30px)';
            setTimeout(() => {
                title.style.transition = 'all 0.8s cubic-bezier(0.16, 1, 0.3, 1)';
                title.style.opacity = '1';
                title.style.transform = 'translateY(0)';
            }, 200);
        }

        if (subtitle) {
            subtitle.style.opacity = '0';
            subtitle.style.transform = 'translateY(20px)';
            setTimeout(() => {
                subtitle.style.transition = 'all 0.8s cubic-bezier(0.16, 1, 0.3, 1)';
                subtitle.style.opacity = '1';
                subtitle.style.transform = 'translateY(0)';
            }, 400);
        }

        insights.forEach((card, i) => {
            card.style.opacity = '0';
            card.style.transform = 'translateY(20px) scale(0.95)';
            setTimeout(() => {
                card.style.transition = 'all 0.6s cubic-bezier(0.16, 1, 0.3, 1)';
                card.style.opacity = '1';
                card.style.transform = 'translateY(0) scale(1)';
            }, 600 + i * 100);
        });
    }

    // ============================================
    // MARKDOWN RENDERING
    // ============================================

    function renderMarkdownContent() {
        // Configure marked for safe rendering
        marked.setOptions({
            breaks: true,
            gfm: true
        });

        // Find all elements with markdown content and render them
        document.querySelectorAll('.section-details-content').forEach(el => {
            const rawContent = el.innerHTML;
            // Replace <br> back to newlines for markdown processing
            const markdownText = rawContent.replace(/<br\\s*\\/?>/gi, '\\n');
            el.innerHTML = marked.parse(markdownText);
        });
    }

    // ============================================
    // KPI TOOLTIPS
    // ============================================

    const KPI_EXPLANATIONS = {
        'Loyalty Threshold': 'The order number where customers become truly loyal. After reaching this point, retention rates jump dramatically. Focus retention efforts on getting customers to this milestone.',
        'Days Warning': 'How many days in advance we can detect that a customer might churn. This is your window to intervene with win-back campaigns.',
        'Fragile Champions': 'Your best customers who are showing signs of disengagement. They\\'ve spent a lot but haven\\'t purchased recently. High priority for personalized outreach.',
        'At Risk': 'Customers showing behavioral patterns that typically precede churn. These customers need immediate attention.',
        'Revenue at Risk': 'The potential revenue you could lose if at-risk customers churn. This is your business case for retention investment.',
        'Conversion Rate': 'The percentage of customers who move from one stage to the next. Low conversion = big leak in your funnel.',
        'Fragility Score': 'A 0-1 score measuring how likely a good customer is to leave. Higher = more fragile. Based on recency and behavioral signals.',
        'Robustness': 'How stable and reliable a customer segment is. High robustness = safe to build campaigns around. Low robustness = segment changes frequently.',
        'Trait Impact': 'How much a customer characteristic affects their value or behavior. High impact traits should drive your segmentation strategy.'
    };

    function initKpiTooltips() {
        document.querySelectorAll('.insight-card').forEach(card => {
            const label = card.querySelector('.insight-label')?.textContent?.trim();
            if (label) {
                // Find matching explanation
                const matchingKey = Object.keys(KPI_EXPLANATIONS).find(key =>
                    label.toLowerCase().includes(key.toLowerCase()) ||
                    key.toLowerCase().includes(label.toLowerCase().split(' ')[0])
                );

                if (matchingKey) {
                    card.setAttribute('title', KPI_EXPLANATIONS[matchingKey]);
                    card.style.cursor = 'help';

                    // Add hover tooltip
                    card.addEventListener('mouseenter', (e) => {
                        showTooltip(e, `<div class="tooltip-title">${label}</div><div style="max-width: 250px; font-size: 0.85rem;">${KPI_EXPLANATIONS[matchingKey]}</div>`);
                    });
                    card.addEventListener('mousemove', moveTooltip);
                    card.addEventListener('mouseleave', hideTooltip);
                }
            }
        });
    }

    // ============================================
    // TOOLTIP HELPERS
    // ============================================

    function showTooltip(event, content) {
        tooltip
            .html(content)
            .classed('visible', true)
            .style('left', (event.pageX + 15) + 'px')
            .style('top', (event.pageY - 10) + 'px');
    }

    function moveTooltip(event) {
        tooltip
            .style('left', (event.pageX + 15) + 'px')
            .style('top', (event.pageY - 10) + 'px');
    }

    function hideTooltip() {
        tooltip.classed('visible', false);
    }

    // ============================================
    // SCROLL-TRIGGERED ANIMATIONS
    // ============================================

    function initScrollAnimations() {
        // Intersection Observer for chart entrance animations
        const chartObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !entry.target.classList.contains('animated')) {
                    entry.target.classList.add('animated');
                    const chartId = entry.target.id.replace('chart-', '');
                    triggerChartEntrance(chartId);
                }
            });
        }, {
            threshold: 0.3,
            rootMargin: '0px 0px -10% 0px'
        });

        // Observe all chart containers
        document.querySelectorAll('[id^="chart-"]').forEach(chart => {
            chart.style.opacity = '0';
            chart.style.transform = 'translateY(30px)';
            chartObserver.observe(chart);
        });

        // Fade in sections as they scroll into view
        const sectionObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('in-view');
                }
            });
        }, {
            threshold: 0.1
        });

        document.querySelectorAll('.essay-section').forEach(section => {
            sectionObserver.observe(section);
        });
    }

    function triggerChartEntrance(chartId) {
        const container = document.getElementById('chart-' + chartId);
        if (!container) return;

        // Fade in container
        container.style.transition = 'opacity 0.8s ease-out, transform 0.8s ease-out';
        container.style.opacity = '1';
        container.style.transform = 'translateY(0)';

        // Trigger chart-specific entrance animations
        const svg = d3.select(container).select('svg');
        const chartType = state.charts[chartId]?.type;

        switch (chartType) {
            case 'sankey':
                animateSankeyEntrance(svg);
                break;
            case 'scatter':
                animateScatterEntrance(svg);
                break;
            case 'bar':
                animateBarEntrance(svg);
                break;
            case 'donut':
                animateDonutEntrance(svg);
                break;
            case 'heatmap':
                animateHeatmapEntrance(svg);
                break;
            case 'timeline':
                animateTimelineEntrance(svg);
                break;
        }
    }

    function animateSankeyEntrance(svg) {
        // Nodes pop in with stagger
        svg.selectAll('.node')
            .attr('r', 0)
            .transition()
            .duration(600)
            .delay((d, i) => i * 100)
            .ease(d3.easeElasticOut.amplitude(1).period(0.5))
            .attr('r', d => d.radius || 25);

        // Links draw in
        svg.selectAll('.link')
            .attr('stroke-dasharray', function() {
                return this.getTotalLength ? this.getTotalLength() : 500;
            })
            .attr('stroke-dashoffset', function() {
                return this.getTotalLength ? this.getTotalLength() : 500;
            })
            .attr('opacity', 0.6)
            .transition()
            .duration(1200)
            .delay(400)
            .ease(d3.easeCubicInOut)
            .attr('stroke-dashoffset', 0);
    }

    function animateScatterEntrance(svg) {
        // Points burst in from center
        svg.selectAll('circle')
            .each(function() {
                const cx = d3.select(this).attr('cx');
                const cy = d3.select(this).attr('cy');
                d3.select(this)
                    .attr('data-cx', cx)
                    .attr('data-cy', cy)
                    .attr('cx', 300)
                    .attr('cy', 200)
                    .attr('r', 0)
                    .attr('opacity', 0);
            })
            .transition()
            .duration(800)
            .delay((d, i) => Math.random() * 500)
            .ease(d3.easeBackOut.overshoot(1.5))
            .attr('cx', function() { return d3.select(this).attr('data-cx'); })
            .attr('cy', function() { return d3.select(this).attr('data-cy'); })
            .attr('r', 8)
            .attr('opacity', 0.75);
    }

    function animateBarEntrance(svg) {
        // Bars grow from bottom
        svg.selectAll('.bar-rect, rect')
            .each(function() {
                const height = d3.select(this).attr('height');
                const y = d3.select(this).attr('y');
                d3.select(this)
                    .attr('data-height', height)
                    .attr('data-y', y)
                    .attr('height', 0)
                    .attr('y', parseFloat(y) + parseFloat(height));
            })
            .transition()
            .duration(800)
            .delay((d, i) => i * 80)
            .ease(d3.easeCubicOut)
            .attr('height', function() { return d3.select(this).attr('data-height'); })
            .attr('y', function() { return d3.select(this).attr('data-y'); });
    }

    function animateDonutEntrance(svg) {
        // Arcs spin in
        svg.selectAll('path')
            .attr('opacity', 0)
            .attr('transform', 'scale(0) rotate(-180)')
            .transition()
            .duration(1000)
            .delay((d, i) => i * 150)
            .ease(d3.easeBackOut.overshoot(1.2))
            .attr('opacity', 1)
            .attr('transform', 'scale(1) rotate(0)');
    }

    function animateHeatmapEntrance(svg) {
        // Cells fade in with wave effect
        svg.selectAll('rect')
            .attr('opacity', 0)
            .attr('transform', 'scale(0.8)')
            .transition()
            .duration(400)
            .delay((d, i) => {
                const row = Math.floor(i / 3);
                const col = i % 3;
                return (row + col) * 100;
            })
            .ease(d3.easeCubicOut)
            .attr('opacity', 1)
            .attr('transform', 'scale(1)');
    }

    function animateTimelineEntrance(svg) {
        // Line draws from left to right
        const path = svg.select('path[fill="none"]');
        if (path.node()) {
            const totalLength = path.node().getTotalLength();
            path.attr('stroke-dasharray', totalLength)
                .attr('stroke-dashoffset', totalLength)
                .transition()
                .duration(2000)
                .ease(d3.easeLinear)
                .attr('stroke-dashoffset', 0);
        }

        // Points pop in after line
        svg.selectAll('circle')
            .attr('r', 0)
            .transition()
            .duration(400)
            .delay((d, i) => 1500 + i * 200)
            .ease(d3.easeElasticOut)
            .attr('r', 8);
    }

    // ============================================
    // SCROLLAMA - STEP TRANSITIONS
    // ============================================

    function initScrollama() {
        document.querySelectorAll('.essay-section').forEach(section => {
            const scroller = scrollama();
            const sectionId = section.id;
            const chartId = section.querySelector('.scrolly')?.dataset.chartId;

            scroller
                .setup({
                    step: `#${sectionId} .step`,
                    offset: 0.5,
                    progress: true
                })
                .onStepEnter(response => {
                    const { element, index, direction } = response;

                    // Smooth step transition
                    section.querySelectorAll('.step').forEach(s => {
                        s.classList.remove('is-active');
                        s.style.opacity = '0.3';
                        s.style.transform = 'translateX(-10px)';
                    });

                    element.classList.add('is-active');
                    element.style.opacity = '1';
                    element.style.transform = 'translateX(0)';
                    element.style.transition = 'all 0.4s ease-out';

                    // Get action and animate chart
                    const action = element.dataset.action;
                    const params = element.dataset.params ? JSON.parse(element.dataset.params) : {};

                    if (chartId && state.charts[chartId]) {
                        updateChartFocus(chartId, action, params, direction);
                    }
                })
                .onStepProgress(response => {
                    const { progress } = response;
                    // Parallax effect on chart based on scroll progress
                    const figure = section.querySelector('.scrolly-figure');
                    if (figure) {
                        const scale = 1 + (progress * 0.02);
                        figure.style.transform = `scale(${scale})`;
                    }
                })
                .onStepExit(response => {
                    const { element } = response;
                    element.style.opacity = '0.3';
                });
        });

        window.addEventListener('resize', scrollama.resize);
    }

    // ============================================
    // CHART FOCUS UPDATES
    // ============================================

    function updateChartFocus(chartId, action, params) {
        const chart = state.charts[chartId];
        if (!chart) return;

        const container = document.getElementById('chart-' + chartId);
        if (!container) return;

        const svg = d3.select(container).select('svg');

        // Reset all elements first
        svg.selectAll('.dimmed').classed('dimmed', false);
        svg.selectAll('.highlighted').classed('highlighted', false);

        switch (action) {
            case 'highlightStage':
            case 'highlightNode':
                highlightById(svg, params.stageId || params.nodeId);
                break;
            case 'highlightDropoff':
                highlightDropoff(svg, params.fromId, params.toId);
                break;
            case 'highlightCategory':
                highlightByCategory(svg, params.category);
                break;
            case 'highlightRisk':
                highlightRisk(svg);
                break;
            case 'showAll':
            case 'init':
                // Already reset above
                break;
        }
    }

    function highlightById(svg, id) {
        svg.selectAll('.funnel-stage, .bar-rect, .scatter-point, .node')
            .classed('dimmed', true)
            .filter(d => d && (d.id === id || d.stage === id || d.label === id))
            .classed('dimmed', false)
            .classed('highlighted', true);
    }

    function highlightDropoff(svg, fromId, toId) {
        svg.selectAll('.funnel-stage')
            .classed('dimmed', true);

        svg.selectAll('.funnel-stage')
            .filter(d => d && (d.id === fromId || d.id === toId))
            .classed('dimmed', false)
            .classed('highlighted', true);
    }

    function highlightByCategory(svg, category) {
        svg.selectAll('.bar-rect, .scatter-point')
            .classed('dimmed', true)
            .filter(d => d && d.category === category)
            .classed('dimmed', false)
            .classed('highlighted', true);
    }

    function highlightRisk(svg) {
        svg.selectAll('.scatter-point')
            .classed('dimmed', true)
            .filter(d => d && d.is_fragile)
            .classed('dimmed', false)
            .classed('highlighted', true);
    }

    // ============================================
    // CHART INITIALIZATION
    // ============================================

    function initCharts() {
        if (!window.ESSAY_DATA) return;

        Object.entries(window.ESSAY_DATA).forEach(([chartId, spec]) => {
            const container = document.getElementById('chart-' + chartId);
            if (!container) return;

            const chart = createChart(container, spec);
            state.charts[chartId] = chart;
        });
    }

    function createChart(container, spec) {
        // Dynamic margins based on chart type
        const chartType = spec.chart_type;
        const needsMoreLeftMargin = ['heatmap', 'horizontal_bar', 'radar'].includes(chartType);
        const needsMoreBottomMargin = ['bar', 'scatter', 'timeline'].includes(chartType);
        const margin = {
            top: 40,
            right: 50,
            bottom: needsMoreBottomMargin ? 80 : 50,
            left: needsMoreLeftMargin ? 145 : 75
        };
        const width = 600;
        const height = 400;
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        d3.select(container).selectAll('*').remove();

        const svg = d3.select(container)
            .append('svg')
            .attr('viewBox', `0 0 ${width} ${height}`)
            .attr('preserveAspectRatio', 'xMidYMid meet');

        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);

        switch (spec.chart_type) {
            case 'funnel':
                return createFunnelChart(g, spec, innerWidth, innerHeight);
            case 'sankey':
                return createSankeyChart(g, spec, innerWidth, innerHeight);
            case 'scatter':
                return createScatterChart(g, spec, innerWidth, innerHeight, margin);
            case 'bar':
                return createBarChart(g, spec, innerWidth, innerHeight);
            case 'horizontal_bar':
                return createHorizontalBarChart(g, spec, innerWidth, innerHeight);
            case 'heatmap':
                return createHeatmapChart(g, spec, innerWidth, innerHeight);
            case 'donut':
                return createDonutChart(g, spec, innerWidth, innerHeight);
            case 'timeline':
                return createTimelineChart(g, spec, innerWidth, innerHeight);
            case 'radar':
                return createRadarChart(g, spec, innerWidth, innerHeight);
            case 'grouped_bar':
                return createGroupedBarChart(g, spec, innerWidth, innerHeight);
            default:
                return createPlaceholder(g, spec, innerWidth, innerHeight);
        }
    }

    // ============================================
    // FUNNEL CHART - RICH VERSION
    // ============================================

    function createFunnelChart(g, spec, width, height) {
        let stages = spec.data?.stages || spec.data || [];
        if (!Array.isArray(stages) || stages.length === 0) {
            return createPlaceholder(g, spec, width, height);
        }

        const valueField = stages[0]?.count !== undefined ? 'count' : 'value';
        const labelField = stages[0]?.stage !== undefined ? 'stage' : 'label';
        const maxValue = d3.max(stages, d => d[valueField]) || 100;

        // Layout: [Label Zone 150px] [Bar Zone] [Percent Zone 120px]
        const labelZone = 160;
        const pctZone = 130;
        const barZone = width - labelZone - pctZone;
        const barStartX = labelZone;

        const stageHeight = Math.min(70, (height - 40) / stages.length);
        const gap = 12;

        // Color scale - gradient from primary to success
        const colorScale = d3.scaleLinear()
            .domain([0, stages.length - 1])
            .range([CONFIG.colors.primary, CONFIG.colors.success]);

        stages.forEach((stage, i) => {
            const value = stage[valueField] || 0;
            const pct = stage.percentage !== undefined ? stage.percentage : (value / stages[0][valueField] * 100);
            const barWidth = Math.max(60, (value / maxValue) * barZone);
            const barX = barStartX + (barZone - barWidth) / 2; // Center bar in bar zone
            const yPos = i * (stageHeight + gap) + 10;

            // Create stage group
            const stageG = g.append('g')
                .attr('class', 'funnel-stage')
                .datum({ id: stage.id || stage[labelField], stage: stage[labelField], value, pct });

            // Main bar with gradient and shadow
            const gradientId = `funnel-grad-${i}-${Date.now()}`;
            const defs = g.append('defs');
            const gradient = defs.append('linearGradient')
                .attr('id', gradientId)
                .attr('x1', '0%').attr('y1', '0%')
                .attr('x2', '100%').attr('y2', '0%');
            gradient.append('stop').attr('offset', '0%').attr('stop-color', d3.color(colorScale(i)).brighter(0.1));
            gradient.append('stop').attr('offset', '100%').attr('stop-color', d3.color(colorScale(i)).darker(0.1));

            // Shadow
            stageG.append('rect')
                .attr('x', barX + 4)
                .attr('y', yPos + 4)
                .attr('width', barWidth)
                .attr('height', stageHeight)
                .attr('fill', 'rgba(0,0,0,0.1)')
                .attr('rx', 10)
                .attr('opacity', 0)
                .transition()
                .duration(600)
                .delay(i * 150)
                .attr('opacity', 1);

            // Animated bar - slides in from left
            stageG.append('rect')
                .attr('x', barStartX)
                .attr('y', yPos)
                .attr('width', 0)
                .attr('height', stageHeight)
                .attr('fill', `url(#${gradientId})`)
                .attr('rx', 10)
                .style('cursor', 'pointer')
                .on('mouseover', function(event) {
                    d3.select(this).transition().duration(150)
                        .attr('transform', 'scale(1.02)')
                        .style('filter', 'brightness(1.1)');
                    const baseline = stage.baseline || stages[0][valueField];
                    let html = `<div class="tooltip-title">${stage[labelField]}</div>`;
                    html += `<div><span class="tooltip-value">${value.toLocaleString()}</span> customers</div>`;
                    html += `<div>${pct.toFixed(1)}% of ${baseline.toLocaleString()} total</div>`;
                    if (stage.drop_off_pct) {
                        html += `<div style="color: #ef4444; margin-top: 4px;">â†“ ${stage.drop_off_pct.toFixed(1)}% drop-off from previous</div>`;
                    }
                    showTooltip(event, html);
                })
                .on('mousemove', moveTooltip)
                .on('mouseout', function() {
                    d3.select(this).transition().duration(150)
                        .attr('transform', 'scale(1)')
                        .style('filter', 'brightness(1)');
                    hideTooltip();
                })
                .transition()
                .duration(800)
                .delay(i * 150)
                .ease(d3.easeCubicOut)
                .attr('x', barX)
                .attr('width', barWidth);

            // Stage label (left zone) - fades in
            stageG.append('text')
                .attr('class', 'funnel-label')
                .attr('x', labelZone - 15)
                .attr('y', yPos + stageHeight / 2)
                .attr('dy', '0.35em')
                .attr('text-anchor', 'end')
                .attr('fill', CONFIG.colors.text)
                .attr('font-size', '0.9rem')
                .attr('font-weight', '500')
                .attr('opacity', 0)
                .text(stage[labelField])
                .transition()
                .duration(500)
                .delay(i * 150 + 200)
                .attr('opacity', 1);

            // Value inside the bar (white text) - counts up
            const valueText = stageG.append('text')
                .attr('class', 'funnel-value')
                .attr('x', barX + barWidth / 2)
                .attr('y', yPos + stageHeight / 2)
                .attr('dy', '0.35em')
                .attr('text-anchor', 'middle')
                .attr('fill', 'white')
                .attr('font-weight', '700')
                .attr('font-size', '1.2rem')
                .attr('opacity', 0)
                .text('0');

            // Animate value counting up
            valueText.transition()
                .duration(800)
                .delay(i * 150 + 300)
                .attr('opacity', 1)
                .tween('text', function() {
                    const interpolate = d3.interpolateNumber(0, value);
                    return function(t) {
                        this.textContent = Math.round(interpolate(t)).toLocaleString();
                    };
                });

            // Percentage (right zone) - slides in from right
            const pctText = `${pct.toFixed(0)}%`;
            const contextText = stage.display_text && stage.display_text.length < 20
                ? stage.display_text.replace(/^[0-9]+%\\s*/, '')
                : `(${value.toLocaleString()} of ${stages[0][valueField].toLocaleString()})`;

            const pctGroup = stageG.append('g')
                .attr('transform', `translate(${width}, ${yPos + stageHeight / 2})`)
                .attr('opacity', 0);

            pctGroup.append('text')
                .attr('class', 'funnel-pct')
                .attr('x', -10)
                .attr('dy', '-0.3em')
                .attr('text-anchor', 'end')
                .attr('font-size', '1rem')
                .attr('font-weight', '600')
                .attr('fill', colorScale(i))
                .text(pctText);

            pctGroup.append('text')
                .attr('class', 'funnel-context')
                .attr('x', -10)
                .attr('dy', '1em')
                .attr('text-anchor', 'end')
                .attr('font-size', '0.7rem')
                .attr('fill', CONFIG.colors.muted)
                .text(contextText);

            pctGroup.transition()
                .duration(500)
                .delay(i * 150 + 400)
                .attr('opacity', 1);

            // Connecting flow line between stages
            if (i > 0) {
                const prevBarWidth = Math.max(60, (stages[i-1][valueField] / maxValue) * barZone);
                const prevBarX = barStartX + (barZone - prevBarWidth) / 2;
                const prevYBottom = (i - 1) * (stageHeight + gap) + 10 + stageHeight;

                const flowPath = d3.path();
                flowPath.moveTo(prevBarX, prevYBottom);
                flowPath.lineTo(prevBarX + prevBarWidth, prevYBottom);
                flowPath.lineTo(barX + barWidth, yPos);
                flowPath.lineTo(barX, yPos);
                flowPath.closePath();

                stageG.append('path')
                    .attr('class', 'funnel-flow')
                    .attr('d', flowPath.toString())
                    .attr('fill', colorScale(i))
                    .attr('opacity', 0)
                    .transition()
                    .duration(400)
                    .delay(i * 150 + 100)
                    .attr('opacity', 0.15);
            }
        });

        return { type: 'funnel', data: stages };
    }

    // ============================================
    // BAR CHART
    // ============================================

    function createBarChart(g, spec, width, height) {
        let data = spec.data?.bars || spec.data || [];
        if (!Array.isArray(data) || data.length === 0) {
            return createPlaceholder(g, spec, width, height);
        }

        const xField = spec.config?.x || (data[0]?.label !== undefined ? 'label' : 'x');
        const yField = spec.config?.y || (data[0]?.value !== undefined ? 'value' : 'y');

        const x = d3.scaleBand()
            .domain(data.map(d => d[xField]))
            .range([0, width])
            .padding(0.35);

        const y = d3.scaleLinear()
            .domain([0, d3.max(data, d => d[yField]) * 1.1])
            .range([height, 0]);

        // Animated bars
        g.selectAll('.bar-rect')
            .data(data)
            .enter()
            .append('rect')
            .attr('class', 'bar-rect')
            .attr('x', d => x(d[xField]))
            .attr('y', height)
            .attr('width', x.bandwidth())
            .attr('height', 0)
            .attr('fill', CONFIG.colors.primary)
            .attr('rx', 6)
            .style('cursor', 'pointer')
            .on('mouseover', function(event, d) {
                showTooltip(event, `<div class="tooltip-title">${d[xField]}</div><div class="tooltip-value">${d[yField].toLocaleString()}</div>`);
            })
            .on('mousemove', moveTooltip)
            .on('mouseout', hideTooltip)
            .transition()
            .duration(CONFIG.animation.duration)
            .delay((d, i) => i * CONFIG.animation.stagger)
            .ease(CONFIG.animation.easing)
            .attr('y', d => y(d[yField]))
            .attr('height', d => height - y(d[yField]));

        // X Axis with rotated labels for long text
        const xAxis = g.append('g')
            .attr('class', 'axis')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(x).tickSize(0).tickPadding(12));

        // Rotate and truncate long labels
        xAxis.selectAll('text')
            .attr('transform', 'rotate(-35)')
            .attr('text-anchor', 'end')
            .attr('dx', '-0.5em')
            .attr('dy', '0.5em')
            .each(function() {
                const text = d3.select(this);
                const label = text.text();
                if (label.length > 15) {
                    text.text(label.substring(0, 12) + '...');
                    text.append('title').text(label); // Full text on hover
                }
            });

        // Y Axis
        g.append('g')
            .attr('class', 'axis')
            .call(d3.axisLeft(y).ticks(5).tickSize(-width).tickPadding(12))
            .call(g => g.selectAll('.tick line').attr('stroke', '#e2e8f0').attr('stroke-dasharray', '4,4'))
            .call(g => g.select('.domain').remove());

        // Y Axis label
        const yLabel = spec.config?.yLabel || spec.config?.title || 'Value';
        g.append('text')
            .attr('class', 'axis-label')
            .attr('transform', 'rotate(-90)')
            .attr('x', -height / 2)
            .attr('y', -50)
            .attr('text-anchor', 'middle')
            .attr('font-size', '0.75rem')
            .attr('fill', CONFIG.colors.muted)
            .text(yLabel);

        return { type: 'bar', data };
    }

    // ============================================
    // HORIZONTAL BAR CHART
    // ============================================

    function createHorizontalBarChart(g, spec, width, height) {
        let data = spec.data || [];
        if (!Array.isArray(data) || data.length === 0) {
            return createPlaceholder(g, spec, width, height);
        }

        const xField = spec.config?.x || 'x';
        const yField = spec.config?.y || 'y';

        const y = d3.scaleBand()
            .domain(data.map(d => d[yField]))
            .range([0, height])
            .padding(0.35);

        const x = d3.scaleLinear()
            .domain([0, d3.max(data, d => d[xField]) * 1.1])
            .range([0, width]);

        // Animated bars
        g.selectAll('.bar-rect')
            .data(data)
            .enter()
            .append('rect')
            .attr('class', 'bar-rect')
            .attr('x', 0)
            .attr('y', d => y(d[yField]))
            .attr('width', 0)
            .attr('height', y.bandwidth())
            .attr('fill', d => d.color || CONFIG.colors.primary)
            .attr('rx', 6)
            .style('cursor', 'pointer')
            .on('mouseover', function(event, d) {
                showTooltip(event, `<div class="tooltip-title">${d[yField]}</div><div class="tooltip-value">${d[xField].toLocaleString()}</div>`);
            })
            .on('mousemove', moveTooltip)
            .on('mouseout', hideTooltip)
            .transition()
            .duration(CONFIG.animation.duration)
            .delay((d, i) => i * CONFIG.animation.stagger)
            .ease(CONFIG.animation.easing)
            .attr('width', d => x(d[xField]));

        // Value labels
        g.selectAll('.bar-label')
            .data(data)
            .enter()
            .append('text')
            .attr('class', 'axis-label')
            .attr('x', d => x(d[xField]) + 8)
            .attr('y', d => y(d[yField]) + y.bandwidth() / 2)
            .attr('dy', '0.35em')
            .attr('opacity', 0)
            .text(d => d[xField].toLocaleString())
            .transition()
            .delay((d, i) => i * CONFIG.animation.stagger + 400)
            .attr('opacity', 1);

        // Y Axis
        g.append('g')
            .attr('class', 'axis')
            .call(d3.axisLeft(y).tickSize(0).tickPadding(12));

        return { type: 'horizontal_bar', data };
    }

    // ============================================
    // SCATTER CHART
    // ============================================

    function createScatterChart(g, spec, width, height, margin) {
        let data = spec.data?.points || spec.data || [];
        if (!Array.isArray(data) || data.length === 0) {
            return createPlaceholder(g, spec, width, height);
        }

        const xField = spec.config?.x || 'x';
        const yField = spec.config?.y || 'y';
        const xLabel = spec.config?.xLabel || xField;
        const yLabel = spec.config?.yLabel || yField;

        const xExtent = d3.extent(data, d => d[xField]);
        const yExtent = d3.extent(data, d => d[yField]);

        const x = d3.scaleLinear()
            .domain([Math.min(0, xExtent[0] * 0.9), xExtent[1] * 1.1])
            .range([0, width]);

        const y = d3.scaleLinear()
            .domain([0, yExtent[1] * 1.15])
            .range([height, 0]);

        // Grid
        g.append('g')
            .attr('class', 'axis')
            .call(d3.axisLeft(y).ticks(5).tickSize(-width).tickPadding(12))
            .call(g => g.selectAll('.tick line').attr('stroke', '#e2e8f0').attr('stroke-dasharray', '4,4'))
            .call(g => g.select('.domain').remove());

        // Animated circles
        g.selectAll('.scatter-point')
            .data(data)
            .enter()
            .append('circle')
            .attr('class', 'scatter-point')
            .attr('cx', d => x(d[xField]))
            .attr('cy', d => y(d[yField]))
            .attr('r', 0)
            .attr('fill', d => d.is_fragile ? CONFIG.colors.danger : CONFIG.colors.primary)
            .attr('opacity', 0.75)
            .attr('stroke', 'white')
            .attr('stroke-width', 2)
            .style('cursor', 'pointer')
            .on('mouseover', function(event, d) {
                d3.select(this).transition().duration(150).attr('r', Math.sqrt(d.size || 80) * 1.4);
                let html = `<div class="tooltip-title">${d.label || d.id || 'Customer'}</div>`;
                html += `<div>${xLabel}: ${d[xField].toFixed(2)}</div>`;
                html += `<div>${yLabel}: ${d[yField].toFixed(2)}</div>`;
                if (d.is_fragile) html += `<div style="color: #ef4444; margin-top: 4px;">âš  At Risk</div>`;
                showTooltip(event, html);
            })
            .on('mousemove', moveTooltip)
            .on('mouseout', function(event, d) {
                d3.select(this).transition().duration(150).attr('r', Math.sqrt(d.size || 80));
                hideTooltip();
            })
            .transition()
            .duration(CONFIG.animation.duration)
            .delay((d, i) => i * 15)
            .ease(CONFIG.animation.easing)
            .attr('r', d => Math.sqrt(d.size || 80));

        // X Axis
        g.append('g')
            .attr('class', 'axis')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(x).ticks(5).tickPadding(12));

        // Axis labels
        g.append('text')
            .attr('class', 'axis-label')
            .attr('x', width / 2)
            .attr('y', height + 40)
            .attr('text-anchor', 'middle')
            .text(xLabel);

        g.append('text')
            .attr('class', 'axis-label')
            .attr('transform', 'rotate(-90)')
            .attr('x', -height / 2)
            .attr('y', -45)
            .attr('text-anchor', 'middle')
            .text(yLabel);

        // Legend for fragility status
        const hasFragileData = data.some(d => d.is_fragile !== undefined);
        if (hasFragileData) {
            const legend = g.append('g')
                .attr('transform', `translate(${width - 100}, 10)`);

            const legendItems = [
                { label: 'At Risk', color: CONFIG.colors.danger },
                { label: 'Stable', color: CONFIG.colors.primary }
            ];

            legendItems.forEach((item, i) => {
                const legendRow = legend.append('g')
                    .attr('transform', `translate(0, ${i * 22})`);

                legendRow.append('circle')
                    .attr('cx', 7)
                    .attr('cy', 7)
                    .attr('r', 6)
                    .attr('fill', item.color)
                    .attr('opacity', 0.75);

                legendRow.append('text')
                    .attr('x', 20)
                    .attr('y', 11)
                    .attr('font-size', '0.75rem')
                    .attr('fill', CONFIG.colors.text)
                    .text(item.label);
            });
        }

        return { type: 'scatter', data };
    }

    // ============================================
    // SANKEY CHART
    // ============================================

    function createSankeyChart(g, spec, width, height) {
        const nodes = spec.data?.nodes || [];
        const links = spec.data?.links || [];

        if (nodes.length === 0) {
            return createPlaceholder(g, spec, width, height);
        }

        // Position nodes by group (sorted by group number for left-to-right flow)
        const nodesByGroup = d3.group(nodes, d => d.group ?? 0);
        const sortedGroups = Array.from(nodesByGroup.entries()).sort((a, b) => a[0] - b[0]);
        const numCols = sortedGroups.length || 1;
        const colWidth = width / (numCols + 1);

        sortedGroups.forEach(([groupNum, colNodes], colIndex) => {
            const rowHeight = height / (colNodes.length + 1);
            colNodes.forEach((node, i) => {
                node.x = (colIndex + 1) * colWidth;
                node.y = (i + 1) * rowHeight;
            });
        });

        const nodeMap = new Map(nodes.map(n => [n.id, n]));

        // Links - use source_id/target_id for string IDs, fallback to source/target
        g.selectAll('.link')
            .data(links)
            .enter()
            .append('path')
            .attr('class', 'link')
            .attr('d', d => {
                const sourceId = d.source_id || d.source;
                const targetId = d.target_id || d.target;
                const source = nodeMap.get(sourceId);
                const target = nodeMap.get(targetId);
                if (!source || !target) return '';
                return `M${source.x},${source.y} C${(source.x + target.x) / 2},${source.y} ${(source.x + target.x) / 2},${target.y} ${target.x},${target.y}`;
            })
            .attr('fill', 'none')
            .attr('stroke', '#cbd5e1')
            .attr('stroke-width', d => Math.max(2, Math.sqrt(d.value) / 2))
            .attr('opacity', 0)
            .style('cursor', 'pointer')
            .on('mouseover', function(event, d) {
                d3.select(this).transition().duration(150).attr('stroke', CONFIG.colors.primary).attr('opacity', 0.7);
                const sourceName = d.source_id || d.source;
                const targetName = d.target_id || d.target;
                showTooltip(event, `<div class="tooltip-title">${sourceName} â†’ ${targetName}</div><div class="tooltip-value">${d.value?.toLocaleString() || 'N/A'}</div>`);
            })
            .on('mousemove', moveTooltip)
            .on('mouseout', function() {
                d3.select(this).transition().duration(150).attr('stroke', '#cbd5e1').attr('opacity', 0.4);
                hideTooltip();
            })
            .transition()
            .duration(CONFIG.animation.duration)
            .delay((d, i) => i * 30)
            .attr('opacity', 0.4);

        // Nodes
        g.selectAll('.node')
            .data(nodes)
            .enter()
            .append('circle')
            .attr('class', 'node')
            .attr('cx', d => d.x)
            .attr('cy', d => d.y)
            .attr('r', 0)
            .attr('fill', (d, i) => CONFIG.colors.chart[i % CONFIG.colors.chart.length])
            .attr('stroke', 'white')
            .attr('stroke-width', 3)
            .style('cursor', 'pointer')
            .on('mouseover', function(event, d) {
                d3.select(this).transition().duration(150).attr('r', Math.sqrt(d.value || 100) / 2 + 15);
                showTooltip(event, `<div class="tooltip-title">${d.label || d.id}</div><div class="tooltip-value">${d.value?.toLocaleString() || 'N/A'}</div>`);
            })
            .on('mousemove', moveTooltip)
            .on('mouseout', function(event, d) {
                d3.select(this).transition().duration(150).attr('r', Math.sqrt(d.value || 100) / 2 + 10);
                hideTooltip();
            })
            .transition()
            .duration(CONFIG.animation.duration)
            .delay((d, i) => i * CONFIG.animation.stagger)
            .attr('r', d => Math.sqrt(d.value || 100) / 2 + 10);

        // Node labels
        g.selectAll('.node-label')
            .data(nodes)
            .enter()
            .append('text')
            .attr('class', 'axis-label')
            .attr('x', d => d.x)
            .attr('y', d => d.y + Math.sqrt(d.value || 100) / 2 + 25)
            .attr('text-anchor', 'middle')
            .text(d => d.label || d.id);

        return { type: 'sankey', nodes, links };
    }

    // ============================================
    // HEATMAP CHART
    // ============================================

    function createHeatmapChart(g, spec, width, height) {
        let data = spec.data || [];
        if (!Array.isArray(data) || data.length === 0) {
            return createPlaceholder(g, spec, width, height);
        }

        const xField = spec.config?.x || 'dimension';
        const yField = spec.config?.y || 'trait';
        const valueField = spec.config?.value || 'value';

        const xValues = [...new Set(data.map(d => d[xField]))];
        const yValues = [...new Set(data.map(d => d[yField]))];

        const x = d3.scaleBand().domain(xValues).range([0, width]).padding(0.08);
        const y = d3.scaleBand().domain(yValues).range([0, height]).padding(0.08);
        const color = d3.scaleSequential(d3.interpolateYlOrRd).domain([0, 1]);

        // Cells
        g.selectAll('.cell')
            .data(data)
            .enter()
            .append('rect')
            .attr('class', 'cell')
            .attr('x', d => x(d[xField]))
            .attr('y', d => y(d[yField]))
            .attr('width', x.bandwidth())
            .attr('height', y.bandwidth())
            .attr('fill', '#f1f5f9')
            .attr('rx', 6)
            .style('cursor', 'pointer')
            .on('mouseover', function(event, d) {
                d3.select(this).transition().duration(150).attr('stroke', '#1a1a2e').attr('stroke-width', 2);
                showTooltip(event, `<div class="tooltip-title">${d[yField]}</div><div>${d[xField]}: ${(d[valueField] * 100).toFixed(1)}%</div>`);
            })
            .on('mousemove', moveTooltip)
            .on('mouseout', function() {
                d3.select(this).transition().duration(150).attr('stroke', 'none');
                hideTooltip();
            })
            .transition()
            .duration(CONFIG.animation.duration)
            .delay((d, i) => i * 20)
            .attr('fill', d => color(d[valueField]));

        // Axes
        g.append('g')
            .attr('class', 'axis')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(x).tickSize(0).tickPadding(12));

        g.append('g')
            .attr('class', 'axis')
            .call(d3.axisLeft(y).tickSize(0).tickPadding(12));

        // Color legend (gradient bar)
        const legendWidth = 120;
        const legendHeight = 12;
        const legendG = g.append('g')
            .attr('transform', `translate(${width - legendWidth - 10}, -25)`);

        // Gradient definition
        const defs = legendG.append('defs');
        const gradient = defs.append('linearGradient')
            .attr('id', 'heatmap-gradient')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '100%').attr('y2', '0%');

        gradient.append('stop').attr('offset', '0%').attr('stop-color', d3.interpolateYlOrRd(0));
        gradient.append('stop').attr('offset', '50%').attr('stop-color', d3.interpolateYlOrRd(0.5));
        gradient.append('stop').attr('offset', '100%').attr('stop-color', d3.interpolateYlOrRd(1));

        legendG.append('rect')
            .attr('width', legendWidth)
            .attr('height', legendHeight)
            .attr('rx', 3)
            .style('fill', 'url(#heatmap-gradient)');

        legendG.append('text')
            .attr('x', 0)
            .attr('y', legendHeight + 12)
            .attr('font-size', '0.65rem')
            .attr('fill', CONFIG.colors.muted)
            .text('Low');

        legendG.append('text')
            .attr('x', legendWidth)
            .attr('y', legendHeight + 12)
            .attr('text-anchor', 'end')
            .attr('font-size', '0.65rem')
            .attr('fill', CONFIG.colors.muted)
            .text('High');

        return { type: 'heatmap', data };
    }

    // ============================================
    // DONUT CHART
    // ============================================

    function createDonutChart(g, spec, width, height) {
        let data = spec.data?.segments || spec.data || [];
        if (!Array.isArray(data)) {
            if (typeof data === 'object') {
                data = Object.entries(data).map(([key, value]) => ({ label: key, value }));
            } else {
                data = [];
            }
        }
        if (data.length === 0) return createPlaceholder(g, spec, width, height);

        const radius = Math.min(width, height) / 2 - 20;
        const valueField = spec.config?.value || (data[0]?.count !== undefined ? 'count' : 'value');
        const labelField = spec.config?.label || (data[0]?.tier !== undefined ? 'tier' : 'label');

        const chartG = g.append('g')
            .attr('transform', `translate(${width/2},${height/2})`);

        const pie = d3.pie().value(d => d[valueField]).sort(null).padAngle(0.02);
        const arc = d3.arc().innerRadius(radius * 0.55).outerRadius(radius * 0.9);
        const arcHover = d3.arc().innerRadius(radius * 0.55).outerRadius(radius * 0.98);

        const total = d3.sum(data, d => d[valueField]);

        chartG.selectAll('path')
            .data(pie(data))
            .enter()
            .append('path')
            .attr('fill', (d, i) => d.data.color || CONFIG.colors.chart[i % CONFIG.colors.chart.length])
            .attr('stroke', 'white')
            .attr('stroke-width', 3)
            .attr('d', d3.arc().innerRadius(radius * 0.55).outerRadius(radius * 0.55))
            .style('cursor', 'pointer')
            .on('mouseover', function(event, d) {
                d3.select(this).transition().duration(150).attr('d', arcHover);
                const pct = total > 0 ? (d.data[valueField] / total * 100).toFixed(1) : 0;
                showTooltip(event, `<div class="tooltip-title">${d.data[labelField]}</div><div class="tooltip-value">${d.data[valueField].toLocaleString()}</div><div>${pct}%</div>`);
            })
            .on('mousemove', moveTooltip)
            .on('mouseout', function() {
                d3.select(this).transition().duration(150).attr('d', arc);
                hideTooltip();
            })
            .transition()
            .duration(CONFIG.animation.duration)
            .attrTween('d', function(d) {
                const interpolate = d3.interpolate({ startAngle: 0, endAngle: 0 }, d);
                return t => arc(interpolate(t));
            });

        // Center text
        chartG.append('text')
            .attr('text-anchor', 'middle')
            .attr('dy', '-0.1em')
            .attr('font-size', '2rem')
            .attr('font-weight', '800')
            .attr('fill', '#1a1a2e')
            .text(spec.config?.centerText || total.toLocaleString());

        chartG.append('text')
            .attr('text-anchor', 'middle')
            .attr('dy', '1.5em')
            .attr('font-size', '0.85rem')
            .attr('fill', CONFIG.colors.muted)
            .text(spec.config?.centerSubtext || 'Total');

        // Legend
        const legend = g.append('g')
            .attr('transform', `translate(${width - 100}, 10)`);

        data.forEach((d, i) => {
            const legendRow = legend.append('g')
                .attr('transform', `translate(0, ${i * 22})`);

            legendRow.append('rect')
                .attr('width', 14)
                .attr('height', 14)
                .attr('rx', 3)
                .attr('fill', d.color || CONFIG.colors.chart[i % CONFIG.colors.chart.length]);

            legendRow.append('text')
                .attr('x', 20)
                .attr('y', 11)
                .attr('font-size', '0.75rem')
                .attr('fill', CONFIG.colors.text)
                .text(d[labelField] || d.label || `Segment ${i+1}`);
        });

        return { type: 'donut', data };
    }

    // ============================================
    // TIMELINE CHART
    // ============================================

    function createTimelineChart(g, spec, width, height) {
        let data = spec.data?.indicators || spec.data || [];
        if (!Array.isArray(data) || data.length === 0) {
            return createPlaceholder(g, spec, width, height);
        }

        // Support both 'days_before' and 'avg_days_before_churn' field names
        const getDays = d => d.days_before ?? d.avg_days_before_churn ?? 0;

        const x = d3.scaleLinear()
            .domain([d3.max(data, getDays) || 90, 0])
            .range([0, width]);

        const y = d3.scaleLinear()
            .domain([0, d3.max(data, d => d.importance) * 1.1 || 1])
            .range([height, 0]);

        // Area
        const area = d3.area()
            .x(d => x(getDays(d)))
            .y0(height)
            .y1(d => y(d.importance))
            .curve(d3.curveMonotoneX);

        g.append('path')
            .datum(data.sort((a, b) => getDays(b) - getDays(a)))
            .attr('fill', CONFIG.colors.danger)
            .attr('fill-opacity', 0.1)
            .attr('d', area);

        // Line
        const line = d3.line()
            .x(d => x(getDays(d)))
            .y(d => y(d.importance))
            .curve(d3.curveMonotoneX);

        const path = g.append('path')
            .datum(data)
            .attr('fill', 'none')
            .attr('stroke', CONFIG.colors.danger)
            .attr('stroke-width', 3)
            .attr('d', line);

        // Animate line
        const totalLength = path.node().getTotalLength();
        path.attr('stroke-dasharray', totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(1500)
            .ease(d3.easeLinear)
            .attr('stroke-dashoffset', 0);

        // Points
        g.selectAll('circle')
            .data(data)
            .enter()
            .append('circle')
            .attr('cx', d => x(getDays(d)))
            .attr('cy', d => y(d.importance))
            .attr('r', 0)
            .attr('fill', d => d.color || CONFIG.colors.danger)
            .attr('stroke', 'white')
            .attr('stroke-width', 2)
            .style('cursor', 'pointer')
            .on('mouseover', function(event, d) {
                d3.select(this).transition().duration(150).attr('r', 12);
                showTooltip(event, `<div class="tooltip-title">${d.indicator || d.name || 'Indicator'}</div><div>Days before: ${getDays(d)}</div><div>Importance: ${(d.importance * 100).toFixed(1)}%</div>`);
            })
            .on('mousemove', moveTooltip)
            .on('mouseout', function() {
                d3.select(this).transition().duration(150).attr('r', 8);
                hideTooltip();
            })
            .transition()
            .duration(400)
            .delay((d, i) => 1000 + i * 100)
            .attr('r', 8);

        // X Axis - fewer ticks to prevent overlap
        const xAxis = g.append('g')
            .attr('class', 'axis')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(x)
                .ticks(6)
                .tickFormat(d => d + 'd')
                .tickPadding(8));

        // Add x-axis label
        g.append('text')
            .attr('class', 'axis-label')
            .attr('x', width / 2)
            .attr('y', height + 35)
            .attr('text-anchor', 'middle')
            .attr('font-size', '0.75rem')
            .attr('fill', CONFIG.colors.muted)
            .text('Days Before Churn');

        // Y Axis
        g.append('g')
            .attr('class', 'axis')
            .call(d3.axisLeft(y).ticks(5).tickFormat(d => (d * 100) + '%').tickSize(-width).tickPadding(12))
            .call(g => g.selectAll('.tick line').attr('stroke', '#e2e8f0').attr('stroke-dasharray', '4,4'))
            .call(g => g.select('.domain').remove());

        // Add y-axis label
        g.append('text')
            .attr('class', 'axis-label')
            .attr('transform', 'rotate(-90)')
            .attr('x', -height / 2)
            .attr('y', -45)
            .attr('text-anchor', 'middle')
            .attr('font-size', '0.75rem')
            .attr('fill', CONFIG.colors.muted)
            .text('Signal Strength');

        // Add legend for indicator colors
        const legendData = [
            { color: '#fc8181', label: 'High importance' },
            { color: '#f6ad55', label: 'Medium importance' },
            { color: '#4299e1', label: 'Lower importance' }
        ];
        const legend = g.append('g')
            .attr('transform', `translate(${width - 110}, 5)`);

        legendData.forEach((item, i) => {
            const row = legend.append('g')
                .attr('transform', `translate(0, ${i * 18})`);
            row.append('circle')
                .attr('cx', 6).attr('cy', 6).attr('r', 5)
                .attr('fill', item.color);
            row.append('text')
                .attr('x', 16).attr('y', 10)
                .attr('font-size', '0.7rem')
                .attr('fill', CONFIG.colors.muted)
                .text(item.label);
        });

        return { type: 'timeline', data };
    }

    // ============================================
    // RADAR CHART
    // ============================================

    function createRadarChart(g, spec, width, height) {
        const axes = spec.data?.axes || [];
        const series = spec.data?.series || [];

        if (axes.length === 0) return createPlaceholder(g, spec, width, height);

        const radius = Math.min(width, height) / 2 - 40;
        const angleSlice = (Math.PI * 2) / axes.length;

        const chartG = g.append('g')
            .attr('transform', `translate(${width/2},${height/2})`);

        const rScale = d3.scaleLinear().domain([0, 1]).range([0, radius]);

        // Grid
        [0.25, 0.5, 0.75, 1].forEach(level => {
            chartG.append('circle')
                .attr('r', rScale(level))
                .attr('fill', 'none')
                .attr('stroke', '#e2e8f0')
                .attr('stroke-dasharray', '4,4');
        });

        // Axes
        axes.forEach((axis, i) => {
            const angle = angleSlice * i - Math.PI / 2;
            chartG.append('line')
                .attr('x1', 0).attr('y1', 0)
                .attr('x2', rScale(1) * Math.cos(angle))
                .attr('y2', rScale(1) * Math.sin(angle))
                .attr('stroke', '#cbd5e1');

            chartG.append('text')
                .attr('x', (rScale(1) + 20) * Math.cos(angle))
                .attr('y', (rScale(1) + 20) * Math.sin(angle))
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('font-size', '12px')
                .attr('font-weight', '600')
                .attr('fill', '#475569')
                .text(axis);
        });

        // Series
        series.forEach((s, si) => {
            const color = CONFIG.colors.chart[si % CONFIG.colors.chart.length];
            const points = s.values.map((v, i) => {
                const angle = angleSlice * i - Math.PI / 2;
                return [rScale(v) * Math.cos(angle), rScale(v) * Math.sin(angle)];
            });

            chartG.append('polygon')
                .attr('points', points.map(() => '0,0').join(' '))
                .attr('fill', color)
                .attr('fill-opacity', 0.2)
                .attr('stroke', color)
                .attr('stroke-width', 2)
                .style('cursor', 'pointer')
                .on('mouseover', function(event) {
                    d3.select(this).transition().duration(150).attr('fill-opacity', 0.4);
                    let html = `<div class="tooltip-title">${s.name || 'Series'}</div>`;
                    s.values.forEach((v, i) => {
                        html += `<div>${axes[i]}: ${(v * 100).toFixed(0)}%</div>`;
                    });
                    showTooltip(event, html);
                })
                .on('mousemove', moveTooltip)
                .on('mouseout', function() {
                    d3.select(this).transition().duration(150).attr('fill-opacity', 0.2);
                    hideTooltip();
                })
                .transition()
                .duration(CONFIG.animation.duration)
                .delay(si * 200)
                .attr('points', points.map(p => p.join(',')).join(' '));
        });

        return { type: 'radar', axes, series };
    }

    // ============================================
    // GROUPED BAR CHART
    // ============================================

    function createGroupedBarChart(g, spec, width, height) {
        let data = spec.data || [];
        if (!Array.isArray(data) || data.length === 0) {
            return createPlaceholder(g, spec, width, height);
        }

        const xField = spec.config?.x || 'metric';
        const groups = spec.config?.groups || ['Group1', 'Group2'];
        const colors = spec.config?.colors || [CONFIG.colors.primary, CONFIG.colors.danger];

        const x0 = d3.scaleBand().domain(data.map(d => d[xField])).range([0, width]).padding(0.25);
        const x1 = d3.scaleBand().domain(groups).range([0, x0.bandwidth()]).padding(0.1);
        const yMax = d3.max(data, d => d3.max(groups, g => d[g])) || 10;
        const y = d3.scaleLinear().domain([0, yMax * 1.1]).range([height, 0]);

        data.forEach((d, di) => {
            groups.forEach((group, gi) => {
                g.append('rect')
                    .datum(d)
                    .attr('class', 'bar-rect')
                    .attr('x', x0(d[xField]) + x1(group))
                    .attr('y', height)
                    .attr('width', x1.bandwidth())
                    .attr('height', 0)
                    .attr('fill', colors[gi])
                    .attr('rx', 4)
                    .style('cursor', 'pointer')
                    .on('mouseover', function(event) {
                        showTooltip(event, `<div class="tooltip-title">${d[xField]}</div><div>${group}: ${(d[group] || 0).toLocaleString()}</div>`);
                    })
                    .on('mousemove', moveTooltip)
                    .on('mouseout', hideTooltip)
                    .transition()
                    .duration(CONFIG.animation.duration)
                    .delay(di * 80 + gi * 40)
                    .ease(CONFIG.animation.easing)
                    .attr('y', y(d[group] || 0))
                    .attr('height', height - y(d[group] || 0));
            });
        });

        // Axes
        g.append('g')
            .attr('class', 'axis')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(x0).tickSize(0).tickPadding(12));

        g.append('g')
            .attr('class', 'axis')
            .call(d3.axisLeft(y).ticks(5).tickSize(-width).tickPadding(12))
            .call(g => g.selectAll('.tick line').attr('stroke', '#e2e8f0').attr('stroke-dasharray', '4,4'))
            .call(g => g.select('.domain').remove());

        // Legend
        groups.forEach((group, i) => {
            g.append('rect')
                .attr('x', width - 90)
                .attr('y', i * 24)
                .attr('width', 16)
                .attr('height', 16)
                .attr('fill', colors[i])
                .attr('rx', 4);

            g.append('text')
                .attr('x', width - 68)
                .attr('y', i * 24 + 12)
                .attr('font-size', '12px')
                .attr('fill', '#475569')
                .text(group);
        });

        return { type: 'grouped_bar', data };
    }

    // ============================================
    // PLACEHOLDER
    // ============================================

    function createPlaceholder(g, spec, width, height) {
        g.append('rect')
            .attr('width', width)
            .attr('height', height)
            .attr('fill', '#f8fafc')
            .attr('rx', 12);

        g.append('text')
            .attr('x', width / 2)
            .attr('y', height / 2)
            .attr('text-anchor', 'middle')
            .attr('fill', CONFIG.colors.muted)
            .attr('font-size', '14px')
            .text(`${spec.chart_type || 'Chart'}: No data available`);

        return { type: 'placeholder' };
    }

    // ============================================
    // UTILITIES
    // ============================================

    function initSmoothScroll() {
        document.querySelectorAll('.toc a').forEach(link => {
            link.addEventListener('click', e => {
                e.preventDefault();
                const targetId = link.getAttribute('href').slice(1);
                const target = document.getElementById(targetId);
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });
    }

})();
'''


def save_pudding_essay(html: str, output_path: str | Path) -> None:
    """Save rendered HTML to file."""
    output_path = Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with open(output_path, "w", encoding="utf-8") as f:
        f.write(html)
